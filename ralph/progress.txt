## Codebase Patterns
- The Engine class in packages/core/src/engine.ts acts as a wrapper that delegates to runtime-specific implementations (WebGPUEngine, WebGL2Engine, CPUEngine)
- Auto runtime selection happens in two phases: constructor (synchronous) determines initial runtime to try, initialize() handles async fallback logic
- When adding fallback logic, always clean up (destroy) failed engine instances before creating new ones
- Runtime fallback should always go from most performant to least: WebGPU → WebGL2 → CPU
- Console logging for runtime selection should be explicit about what's being attempted and what succeeded/failed
- All runtime engines extend AbstractEngine which provides: modules (forces+render combined), view, oscillatorManager, and lifecycle methods
- ViewSnapshot uses cx/cy for camera position (not offset.x/offset.y), width/height for size, and zoom
- WebGL2 uses texture-based GPU storage: RGBA32F textures with 3 texels per particle (pos/vel, accel/size/mass, color)
- Ping-pong pattern: read from current texture, write to "other" texture, then swap references
- WebGL2 modules: Read settings directly via module.readValue() at render time (no registry/compiler like WebGPU yet)
- Render modules should check isEnabled() before rendering, but still clear scene even when disabled
- WebGL2 neighbor infrastructure uses textures (cellIds, sortedIndices, cellRanges) since WebGL2 lacks compute shaders/storage buffers
- Grid passes run every frame in simulation loop: assign cells → sort → build ranges, before force application
- GLSL getNeighbors() helper function provides neighbor iteration within radius, respects maxNeighbors limit
- SpacialGrid manages grid configuration and automatically resizes when view changes (pan/zoom/resize)

---

## 2026-01-08 - US-002
Thread: https://ampcode.com/threads/$AMP_CURRENT_THREAD_ID
- Implemented WebGPU → WebGL2 → CPU fallback chain for runtime: "auto"
- Added comprehensive console logging to track runtime selection attempts and results
- Files changed:
  - packages/core/src/engine.ts: Updated constructor and initialize() method
- **Learnings for future iterations:**
  - The Engine class delegates to runtime-specific engine implementations (WebGPUEngine, CPUEngine)
  - Auto mode starts by attempting WebGPU in the constructor, then handles fallback asynchronously in initialize()
  - Each failed runtime must be destroyed before attempting the next one to avoid resource leaks
  - WebGL2 runtime is not yet implemented - it will throw "not yet implemented" error, so fallback to CPU is guaranteed for now
  - Console logs should clearly indicate: what runtime is being attempted, what failed, and what succeeded
  - Typecheck is run via `npm run type-check` (not `typecheck`)
---
## 2026-01-08 - US-003
Thread: https://ampcode.com/threads/$AMP_CURRENT_THREAD_ID
- Implemented WebGL2 GPU particle store using RGBA32F textures with ping-pong rendering
- Created baseline simulation loop on GPU using fragment shaders for Verlet integration
- Files changed:
  - packages/core/src/engine.ts: Added WebGL2Engine import and instantiation
  - packages/core/src/runtimes/webgl2/engine.ts: Main WebGL2Engine class (animate loop, simulation, rendering)
  - packages/core/src/runtimes/webgl2/gl2-resources.ts: WebGL2 resource manager (contexts, textures, FBOs, programs)
  - packages/core/src/runtimes/webgl2/particle-store.ts: CPU-side particle storage with GPU sync
  - packages/core/src/runtimes/webgl2/shaders.ts: GLSL shaders for simulation and rendering
- **Learnings for future iterations:**
  - WebGL2 uses texture-based particle storage: 3 RGBA32F texels per particle (12 floats total)
  - Particle data layout: Texel 0 = [pos.x, pos.y, vel.x, vel.y], Texel 1 = [ax, ay, size, mass], Texel 2 = [r, g, b, a]
  - Ping-pong rendering: simulation passes read from current texture, write to "other" texture, then swap
  - Fragment shaders calculate texel coordinates from gl_FragCoord to determine which particle/texel they're processing
  - Particle rendering uses gl.POINTS with gl_VertexID to fetch particle data from texture in vertex shader
  - ViewSnapshot uses cx/cy (not offset.x/offset.y) for camera position
  - AbstractEngine provides `modules` (combines forces + render), not separate `forces`/`renderModules` properties
  - WebGL2 requires EXT_color_buffer_float extension for rendering to RGBA32F textures
  - Scene rendering also uses ping-pong textures (separate from particle textures)
  - destroy() must cancel animation frame and dispose all GL resources (textures, FBOs, programs, buffers)
---
## 2026-01-08 20:15 - US-004
Thread: https://ampcode.com/threads/$AMP_CURRENT_THREAD_ID
- Implemented WebGL2 render pipeline with Particles module support
- Added Particles.webgl2() render descriptor returning WebGL2Descriptor with color mode bindings
- Enhanced particle vertex shader to pass mass to fragment shader for pinned particle detection
- Implemented 3 color modes in particle fragment shader:
  * Default (0): Uses particle's inherent RGBA color from texture
  * Custom (1): Applies uniform RGB color to all particles
  * Hue (2): Converts HSV hue (0..1) to RGB with full saturation and value
- Added hollow circle (donut) rendering for pinned particles (mass < 0) with smooth edges
- WebGL2Engine now finds Particles module and reads its settings at render time
- Module enabled state properly handled: clears scene but skips particle rendering when disabled
- Enabled alpha blending (SRC_ALPHA, ONE_MINUS_SRC_ALPHA) for smooth transparency
- Scene texture ping-pong working: renders to FBO, presents to canvas
- Clear color respected each frame

Files changed:
- packages/core/src/modules/render/particles.ts: Added webgl2() method with descriptor
- packages/core/src/runtimes/webgl2/shaders.ts: Updated particle vertex/fragment shaders
- packages/core/src/runtimes/webgl2/engine.ts: Integrated Particles module settings
- WEBGL2-PARTICLES-TEST.md: Created browser testing documentation
- test-webgl2-basic.mjs: Created automated smoke tests

**Learnings for future iterations:**
- WebGL2 modules don't use a registry/compiler like WebGPU yet - shaders are handwritten GLSL
- Module descriptors (webgl2()) return WGSL-style code for consistency with WebGPU, but WebGL2 uses direct GLSL
- WebGL2Engine reads module settings directly via readValue() at render time
- Particle shaders use texture lookups (3 texels per particle) for all data: pos/vel, accel/size/mass, color
- Fragment shader gets gl_PointCoord (0..1) to render circular particles with distance-based alpha falloff
- Pinned particles identified by negative mass, rendered as hollow rings using smoothstep for soft edges
- Alpha blending must be explicitly enabled before drawing, disabled after
- Scene FBO must be cleared to clearColor each frame before rendering particles
- Module enabled state check should happen after clearing scene but before rendering

---
## 2026-01-08 - US-005
Thread: https://ampcode.com/threads/$AMP_CURRENT_THREAD_ID
- Implemented WebGL2 GPU kernels for core force modules (Environment, Interaction, Boundary, Grab)
- Created dynamic GLSL shader generation system for applying forces on GPU
- Force modules now support both WebGPU and WebGL2 runtimes with same descriptor API
- Files changed:
  - packages/core/src/modules/forces/environment.ts: Added webgl2() method
  - packages/core/src/modules/forces/interaction.ts: Added webgl2() method
  - packages/core/src/modules/forces/boundary.ts: Added webgl2() method
  - packages/core/src/modules/forces/grab.ts: Added webgl2() method
  - packages/core/src/runtimes/webgl2/engine.ts: Added buildForceShader(), runForcePass(), convertWGSLtoGLSL()
  - packages/core/src/runtimes/webgl2/shaders.ts: Added generateForceFragmentShader()
  - test-webgl2-forces.html: Browser test for force modules
- **Learnings for future iterations:**
  - Force modules return same WebGL2ForceDescriptor structure as WebGPU for API consistency
  - WGSL-style template strings work for both runtimes, converted to GLSL at shader build time
  - WebGL2 force shader is dynamically generated by concatenating force code from enabled modules
  - convertWGSLtoGLSL() handles basic WGSL→GLSL translation: let/var keywords, vec2<f32>, select()
  - Module uniforms follow pattern: u_<moduleName>_<inputName> (e.g., u_environment_gravityStrength)
  - Force pass runs BEFORE integration pass in simulation loop to modify acceleration
  - GRID_MINX/MAXX/MINY/MAXY helpers in force shader calculate world bounds from view uniforms
  - Ping-pong rendering maintains particle state across multiple GPU passes (force → integrate)
  - Boundary modes: 0=bounce, 1=warp, 2=kill, 3=none (matches WebGPU/CPU implementations)
  - Grab uses correct phase (not apply) since it modifies position/velocity directly
  - Environment handles 3 gravity modes: 0=fixed direction, 1=inwards to center, 2=outwards from center
---
## 2026-01-08 - US-006
Thread: https://ampcode.com/threads/$AMP_CURRENT_THREAD_ID
- Implemented WebGL2 neighbor infrastructure for GPU-based neighbor queries
- Added spatial grid system with texture-based storage (cellIds, sortedIndices, cellRanges)
- Created grid shader passes: assign cells, bitonic sort (structure), build ranges
- Implemented GLSL neighbor iterator helpers with getNeighbors() function
- Files changed:
  - packages/core/src/runtimes/webgl2/spacial-grid.ts: New SpacialGrid class for WebGL2
  - packages/core/src/runtimes/webgl2/gl2-resources.ts: Grid texture creation and management
  - packages/core/src/runtimes/webgl2/shaders.ts: Grid shaders and neighbor iterator helpers
  - packages/core/src/runtimes/webgl2/engine.ts: Integrated grid passes into simulation loop
  - test-webgl2-neighbors.html: Browser test for neighbor infrastructure
- **Learnings for future iterations:**
  - WebGL2 uses texture-based grid storage (no compute shaders/storage buffers like WebGPU)
  - Grid data stored in RGBA32F textures: cellIds (1 texel/particle), sortedIndices (cellId+particleId pairs), cellRanges (start+count per cell)
  - Grid passes run every frame: assign cells → sort → build ranges
  - Bitonic sort requires many passes and dynamic shader compilation - documented as performance limitation
  - Current implementation uses unsorted indices for functional but slower neighbor queries
  - A production implementation would use alternative sorting (counting sort, radix sort) or pre-compiled bitonic stages
  - GLSL neighbor iterator scans neighboring cells based on radius, respects maxNeighbors limit
  - Grid bounds calculated from view snapshot (cx, cy, zoom, width, height) to match camera
  - Cell size configurable via engine.setCellSize() - affects neighbor query performance
  - Grid textures automatically resize when view changes (pan, zoom, resize)
  - SpacialGrid.getGridBounds() provides grid extents for shader uniforms
  - Grid passes use fullscreen quad rendering to process all particles/cells in parallel
---
## 2026-01-09 - US-007
Thread: https://ampcode.com/threads/$AMP_CURRENT_THREAD_ID
- Implemented webgl2() methods for all five neighbor-based force modules
- Collisions: GPU neighbor iteration with overlap detection, position correction, impulse-based bounce
- Behavior: Boids-style steering with separation, alignment, cohesion, chase/avoid, wander
- Fluids: SPH-inspired simulation with state + apply passes (density/pressure/viscosity)
- Joints: CSR-based constraint solver with momentum preservation using array inputs
- Sensors: Scene texture sampling for follow/flee steering with color-aware behaviors
- Files changed:
  - packages/core/src/modules/forces/collisions.ts: Added webgl2() with constrain + correct phases
  - packages/core/src/modules/forces/behavior.ts: Added webgl2() with apply phase for boids
  - packages/core/src/modules/forces/fluids.ts: Added webgl2() with state + apply phases
  - packages/core/src/modules/forces/joints.ts: Added webgl2() with state + constrain + correct phases
  - packages/core/src/modules/forces/sensors.ts: Added webgl2() with global + apply phases
- **Learnings for future iterations:**
  - WebGL2 force modules return same descriptor structure as WebGPU for API consistency
  - Neighbor-based modules use getNeighbors() helper function that reads from grid textures
  - Modules read neighbor particle data via texture lookups: getTexelCoord(j, offset), texture()
  - Collisions handles identical-position edge case with pseudo-random separation
  - Behavior accumulates separate/align/cohesion accumulators from neighbor loop
  - Fluids uses two-pass approach: state pass computes density, apply pass uses it for pressure
  - Joints uses CSR (Compressed Sparse Row) format: incidentJointOffsets and incidentJointIndices arrays
  - Sensors module requires scene texture binding (HAS_SCENE_TEXTURE define) for full functionality
  - Each module's WGSL-style code gets converted to GLSL by engine.convertWGSLtoGLSL()
---
## 2026-01-09 - US-008
Thread: https://ampcode.com/threads/$AMP_CURRENT_THREAD_ID
- Implemented webgl2() methods for Lines and Trails render modules
- Lines module uses instanced rendering with R32F textures for particle indices
- Trails module implements decay and diffuse passes with scene texture ping-pong
- WebGL2Engine now handles all render modules in order via renderScene()
- Files changed:
  - packages/core/src/modules/render/lines.ts: Added webgl2() with same descriptor API as WebGPU
  - packages/core/src/modules/render/trails.ts: Added webgl2() with decay + diffuse passes
  - packages/core/src/runtimes/webgl2/engine.ts: Added renderScene(), renderTrails(), renderLinesModule(), updateLineIndicesTextures()
  - packages/core/src/runtimes/webgl2/shaders.ts: Added linesVertexShader, linesFragmentShader, trailsDecayFragmentShader, trailsDiffuseFragmentShader
  - test-webgl2-lines-trails.html: Browser test for Lines + Trails modules
- **Learnings for future iterations:**
  - Lines rendering uses instanced TRIANGLE_STRIP (4 vertices per line quad)
  - Line indices are uploaded to R32F textures (single float per texel) for shader access
  - Trails handles background via decay pass, so it runs BEFORE other render modules
  - Scene texture ping-pong: read from current, write to other, then swap
  - WebGL2 render modules follow same descriptor pattern as WebGPU (WGSL-style code)
  - Render ordering in WebGL2 is handled by iterating modules array in order
---
